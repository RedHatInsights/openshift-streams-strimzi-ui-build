{"version":3,"sources":["webpack://kafka-ui/./src/Contexts/Alert/Context.tsx","webpack://kafka-ui/./src/Contexts/Topic/Context.tsx","webpack://kafka-ui/./src/Panels/Topics/FederatedCreateView.tsx"],"names":["AlertContext","createContext","initialState","name","numPartitions","replicationFactor","preallocate","TopicContext","FederatedCreateTopic","getToken","apiBasePath","onCloseCreateTopic","value","basePath","PageSection","variant","PageSectionVariants","setIsCreateTopic","b"],"mappings":"kIAKaA,G,SAAe,IAAAC,eAC1B,M,oECCWC,EAA8B,CACzCC,KAAM,GACNC,cAAe,GACfC,kBAAmB,GACnB,sBAAuB,GACvB,eAAgB,GAChB,oBAAqB,OACrB,oBAAqB,GACrB,yBAA0B,QAC1B,yBAA0B,aAC1B,sCAAuC,GACvC,2CAA4C,eAC5C,mBAAoB,GACpB,qBAAsB,GACtB,sBAAuB,GACvB,2BAA4B,QAC5B,oBAAqB,GACrB,yBAA0B,QAC1B,iCAAkC,GAClC,0CAA2C,GAC3C,wCAAyC,GACzC,sBAAuB,GACvB,2BAA4B,eAC5B,4BAA6B,GAC7B,wBAAyB,GACzB,6BAA8B,eAC9B,aAAc,GACd,kBAAmB,eACnB,oBAAqB,GACrB,yBAA0B,eAC1B,uBAAwB,GACxB,4BAA6B,eAC7BC,YAAa,GACb,uBAAwB,GACxB,4BAA6B,QAC7B,sBAAuB,GACvB,2BAA4B,QAC5B,iBAAkB,GAClB,sBAAuB,eACvB,WAAY,GACZ,gBAAiB,gBAGNC,GAAe,IAAAN,eAAc,K,oJCtCpCO,EAAqE,SAAC,G,IAC1EC,EAAQ,WACRC,EAAW,cACXC,EAAkB,qBAQlB,OACE,kBAAC,aAAsB,CACrBC,MAAO,CAAEC,SAAUH,EAAaD,SAAQ,IAExC,kBAAC,EAAAK,YAAW,CAACC,QAAS,EAAAC,oBAAA,OACpB,kBAAC,IAAe,CAACC,iBAXE,SAACC,GACnBA,GACHP,UAiBN","file":"359.eda28eb3.bundle.js","sourcesContent":["import React, { createContext, useEffect, useState } from 'react';\nimport { AlertVariant } from '@patternfly/react-core';\nimport { ServerAlertGroup } from '../../Components/ServerAlertGroup/ServerAlertGroup';\nimport { AlertType, AlertContextProps, TimeOut } from './Alert.types';\n\nexport const AlertContext = createContext<AlertContextProps>(\n  {} as AlertContextProps\n);\n\nexport const AlertProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [alerts, setAlerts] = useState<AlertType[]>([]);\n  const [timers, setTimers] = useState<TimeOut[]>([]);\n\n  useEffect(() => {\n    const timersKeys = timers.map((timer) => timer?.key);\n    const timeOuts = alerts\n      .filter((alert) => !timersKeys.includes(alert.key))\n      .map((alert) => {\n        const timeOut = setTimeout(() => hideAlert(alert.key), 8000);\n        return { key: alert.key, timeOut };\n      });\n    setTimers([...timers, ...timeOuts]);\n    return () => timers.forEach((timer) => clearTimeout(timer.timeOut));\n  }, [alerts]);\n\n  const hideAlert = (key: number) => {\n    setAlerts((alerts) => [...alerts.filter((el) => el.key !== key)]);\n    setTimers((timers) => [...timers.filter((timer) => timer.key === key)]);\n  };\n\n  const createId = () => new Date().getTime();\n\n  const addAlert = (\n    message: string,\n    variant: AlertVariant = AlertVariant.default\n  ) => {\n    setAlerts([...alerts, { key: createId(), message, variant }]);\n  };\n\n  return (\n    <AlertContext.Provider value={{ addAlert }}>\n      <ServerAlertGroup alerts={alerts} onCloseAlert={hideAlert} />\n      {children}\n    </AlertContext.Provider>\n  );\n};\n","import React, { createContext, useState } from 'react';\nimport {\n  AdvancedTopic,\n  ITopicProviderProps,\n  TopicContextProp,\n} from './Topic.types';\n\nexport const initialState: AdvancedTopic = {\n  name: '',\n  numPartitions: '',\n  replicationFactor: '',\n  'min.insync.replicas': '',\n  'retention.ms': '',\n  'retention.ms.unit': 'days',\n  'max.message.bytes': '',\n  'max.message.bytes.unit': 'bytes',\n  'message.timestamp.type': 'CreateTime',\n  'message.timestamp.difference.max.ms': '',\n  'message.timestamp.difference.max.ms.unit': 'milliseconds',\n  'compression.type': '',\n  'log.cleanup.policy': '',\n  'log.retention.bytes': '',\n  'log.retention.bytes.unit': 'bytes',\n  'log.segment.bytes': '',\n  'log.segment.bytes.unit': 'bytes',\n  'unclean.leader.election.enable': '',\n  'follower.replication.throttled.replicas': '',\n  'leader.replication.throttled.replicas': '',\n  'delete.retention.ms': '',\n  'delete.retention.ms.unit': 'milliseconds',\n  'min.cleanable.dirty.ratio': '',\n  'min.compaction.lag.ms': '',\n  'min.compaction.lag.ms.unit': 'milliseconds',\n  'segment.ms': '',\n  'segment.ms.unit': 'milliseconds',\n  'segment.jitter.ms': '',\n  'segment.jitter.ms.unit': 'milliseconds',\n  'file.delete.delay.ms': '',\n  'file.delete.delay.ms.unit': 'milliseconds',\n  preallocate: '',\n  'index.interval.bytes': '',\n  'index.interval.bytes.unit': 'bytes',\n  'segment.index.bytes': '',\n  'segment.index.bytes.unit': 'bytes',\n  'flush.messages': '',\n  'flush.messages.unit': 'milliseconds',\n  'flush.ms': '',\n  'flush.ms.unit': 'milliseconds',\n};\n\nexport const TopicContext = createContext({} as TopicContextProp);\n\nexport const TopicContextProvider: React.FC<ITopicProviderProps> = ({\n  children,\n}) => {\n  const [store, setStore] = useState<AdvancedTopic>(initialState);\n\n  const updateStore = (name: string, value: string | boolean | number) => {\n    setStore({\n      ...store,\n      [name]: value.toString(),\n    });\n  };\n\n  const updateBulkStore = (advanceConfig: AdvancedTopic) => {\n    setStore({\n      ...store,\n      ...advanceConfig,\n    });\n  };\n\n  return (\n    <TopicContext.Provider value={{ store, updateStore, updateBulkStore }}>\n      {children}\n    </TopicContext.Provider>\n  );\n};\n","import React, { FunctionComponent } from 'react';\nimport './style.scss';\nimport { ConfigContext, IConfiguration } from '../../Contexts';\nimport { PageSection, PageSectionVariants } from '@patternfly/react-core';\nimport { CreateTopicPage } from 'src/Modules/Topics/CreateTopic/CreateTopicPage';\n\nexport type FederatedCreateTopicProps = {\n  getToken: () => Promise<string>;\n  apiBasePath: string;\n  onCloseCreateTopic: () => void;\n};\n\nconst FederatedCreateTopic: FunctionComponent<FederatedCreateTopicProps> = ({\n  getToken,\n  apiBasePath,\n  onCloseCreateTopic,\n}) => {\n  const setIsCreateTopic = (b: boolean) => {\n    if (!b) {\n      onCloseCreateTopic();\n    }\n  };\n\n  return (\n    <ConfigContext.Provider\n      value={{ basePath: apiBasePath, getToken } as IConfiguration}\n    >\n      <PageSection variant={PageSectionVariants.light}>\n        <CreateTopicPage setIsCreateTopic={setIsCreateTopic} />\n      </PageSection>\n    </ConfigContext.Provider>\n  );\n};\n\nexport { FederatedCreateTopic };\n\nexport default FederatedCreateTopic;\n"],"sourceRoot":""}