{"version":3,"sources":["webpack://kafka-ui/./src/Contexts/Alert/Context.tsx","webpack://kafka-ui/./src/Panels/Topics/FederatedView.tsx","webpack://kafka-ui/./src/Services/TopicServices.tsx"],"names":["AlertContext","createContext","FederatedTopics","getToken","apiBasePath","onCreateTopic","value","basePath","PageSection","variant","PageSectionVariants","getTopics","config","accessToken","getTopicsList","data","deleteTopic","topicName"],"mappings":"kIAKaA,G,SAAe,IAAAC,eAC1B,M,oICMIC,EAA2D,SAAC,G,IAChEC,EAAQ,WACRC,EAAW,cACXC,EAAa,gBAEb,OACE,kBAAC,aAAsB,CAACC,MAAO,CAAEC,SAAUH,EAAaD,SAAQ,IAC9D,kBAAC,EAAAK,YAAW,CAACC,QAAS,EAAAC,oBAAA,OACpB,kBAAC,IAAmB,CAACL,cAAeA,OAQ5C,W,45CCtBaM,EAAY,SACvBC,GAAkC,0C,wDAEd,SAAMA,aAAM,EAANA,EAAQT,Y,OAQU,OARtCU,EAAc,SAQwB,GANhC,IAAI,KACd,IAAI,KAAc,CAChBA,YAAW,EACXN,SAAUK,aAAM,EAANA,EAAQL,YAGgCO,iB,OACtD,MAAO,CAAP,EAD4C,SAC5BC,cA4ELC,EAAc,SACzBC,EACAL,GAAkC,0C,wDAEd,SAAMA,aAAM,EAANA,EAAQT,Y,OAQlC,OARMU,EAAc,SAQpB,GANY,IAAI,KACd,IAAI,KAAc,CAChBA,YAAW,EACXN,SAAUK,aAAM,EAANA,EAAQL,YAGZS,YAAYC,I,OACtB,OADA,SACA","file":"606.174a2472.bundle.js","sourcesContent":["import React, { createContext, useEffect, useState } from 'react';\nimport { AlertVariant } from '@patternfly/react-core';\nimport { ServerAlertGroup } from '../../Components/ServerAlertGroup/ServerAlertGroup';\nimport { AlertType, AlertContextProps, TimeOut } from './Alert.types';\n\nexport const AlertContext = createContext<AlertContextProps>(\n  {} as AlertContextProps\n);\n\nexport const AlertProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [alerts, setAlerts] = useState<AlertType[]>([]);\n  const [timers, setTimers] = useState<TimeOut[]>([]);\n\n  useEffect(() => {\n    const timersKeys = timers.map((timer) => timer?.key);\n    const timeOuts = alerts\n      .filter((alert) => !timersKeys.includes(alert.key))\n      .map((alert) => {\n        const timeOut = setTimeout(() => hideAlert(alert.key), 8000);\n        return { key: alert.key, timeOut };\n      });\n    setTimers([...timers, ...timeOuts]);\n    return () => timers.forEach((timer) => clearTimeout(timer.timeOut));\n  }, [alerts]);\n\n  const hideAlert = (key: number) => {\n    setAlerts((alerts) => [...alerts.filter((el) => el.key !== key)]);\n    setTimers((timers) => [...timers.filter((timer) => timer.key === key)]);\n  };\n\n  const createId = () => new Date().getTime();\n\n  const addAlert = (\n    message: string,\n    variant: AlertVariant = AlertVariant.default\n  ) => {\n    setAlerts([...alerts, { key: createId(), message, variant }]);\n  };\n\n  return (\n    <AlertContext.Provider value={{ addAlert }}>\n      <ServerAlertGroup alerts={alerts} onCloseAlert={hideAlert} />\n      {children}\n    </AlertContext.Provider>\n  );\n};\n","import React, { FunctionComponent } from 'react';\nimport './style.scss';\nimport { TopicsListComponent } from '../../Modules/Topics/TopicList/Components/TopicsList';\nimport { ConfigContext } from '../../Contexts';\nimport { PageSection, PageSectionVariants } from '@patternfly/react-core';\n\nexport type FederatedTopicsProps = {\n  getToken: () => Promise<string>;\n  apiBasePath: string;\n  onCreateTopic: () => void;\n};\n\nconst FederatedTopics: FunctionComponent<FederatedTopicsProps> = ({\n  getToken,\n  apiBasePath,\n  onCreateTopic,\n}) => {\n  return (\n    <ConfigContext.Provider value={{ basePath: apiBasePath, getToken }}>\n      <PageSection variant={PageSectionVariants.light}>\n        <TopicsListComponent onCreateTopic={onCreateTopic} />\n      </PageSection>\n    </ConfigContext.Provider>\n  );\n};\n\nexport { FederatedTopics };\n\nexport default FederatedTopics;\n","import { AxiosResponse } from 'axios';\nimport { AdvancedTopic } from '../Contexts/Topic';\nimport { DefaultApi, Topic, TopicSettings, TopicsList } from '../OpenApi/api';\nimport { Configuration } from '../OpenApi';\nimport { IConfiguration } from '../Contexts';\n\nexport const getTopics = async (\n  config: IConfiguration | undefined\n): Promise<TopicsList> => {\n  const accessToken = await config?.getToken();\n\n  const api = new DefaultApi(\n    new Configuration({\n      accessToken,\n      basePath: config?.basePath,\n    })\n  );\n  const response: AxiosResponse<TopicsList> = await api.getTopicsList();\n  return response.data;\n};\n\nexport const getTopicDetail = async (\n  topicName: string,\n  config: IConfiguration | undefined\n): Promise<AdvancedTopic> => {\n  const accessToken = await config?.getToken();\n\n  const api = new DefaultApi(\n    new Configuration({\n      accessToken,\n      basePath: config?.basePath,\n    })\n  );\n  const { data } = await api.getTopic(topicName);\n\n  return convertTopicResponse(data);\n};\n\nconst convertTopicResponse = (topic: Topic): AdvancedTopic => {\n  const topicObj: any = {};\n\n  topic.config?.forEach((config) => {\n    if (config.key) {\n      topicObj[config.key] = config.value;\n    }\n  });\n\n  topicObj.numPartitions = topic?.partitions?.length;\n\n  topicObj.replicationFactor = topic?.partitions\n    ?.map((p) => p.replicas?.length)\n    .reduce(\n      (previousValue = 0, currentValue = 0) => previousValue + currentValue\n    );\n\n  return topicObj;\n};\n\nexport const updateTopicModel = async (\n  topicName: string,\n  topicSettings: TopicSettings,\n  config: IConfiguration | undefined\n): Promise<number> => {\n  const accessToken = await config?.getToken();\n\n  const api = new DefaultApi(\n    new Configuration({\n      accessToken,\n      basePath: config?.basePath,\n    })\n  );\n  const response: AxiosResponse<Topic> = await api.updateTopic(\n    topicName,\n    topicSettings\n  );\n  return response.status;\n};\n\nexport const getTopic = async (\n  topicName: string,\n  config: IConfiguration | undefined\n): Promise<Topic> => {\n  const accessToken = await config?.getToken();\n\n  const api = new DefaultApi(\n    new Configuration({\n      accessToken,\n      basePath: config?.basePath,\n    })\n  );\n  const response = await api.getTopic(topicName);\n  return response.data;\n};\n\nexport const deleteTopic = async (\n  topicName: string,\n  config: IConfiguration | undefined\n): Promise<void> => {\n  const accessToken = await config?.getToken();\n\n  const api = new DefaultApi(\n    new Configuration({\n      accessToken,\n      basePath: config?.basePath,\n    })\n  );\n  await api.deleteTopic(topicName);\n  return;\n};\n"],"sourceRoot":""}