{"version":3,"sources":["webpack://kafka-ui/./src/components/MASLoading/MASLoading.tsx","webpack://kafka-ui/./src/components/RootModal/RootModal.tsx","webpack://kafka-ui/./src/contexts/Api/Context.tsx","webpack://kafka-ui/./src/contexts/federated.ts","webpack://kafka-ui/./src/i18n/locale/index.ts","webpack://kafka-ui/./src/i18n/index.ts","webpack://kafka-ui/./src/utils/common.ts"],"names":["MASLoading","bullseyeProps","spinnerProps","Bullseye","Spinner","DeleteTopic","lazy","PartitionsChange","DeleteConsumerGroup","MODAL_TYPES","DELETE_TOPIC","DELETE_CONSUMER_GROUP","UPDATE_PARTITIONS","MODAL_COMPONENTS","RootModalContext","createContext","showModal","hideModal","store","useRootModalContext","useContext","RootModal","ModalComponent","children","useState","setStore","modalType","modalProps","fallback","Provider","value","newState","Object","assign","id","ConfigContext","undefined","initialState","onConnectToRoute","getConnectToRoutePath","activeTab","kafkaName","kafkaPageLink","kafkaInstanceLink","topicName","onError","handleInstanceDrawer","setIsOpenDeleteInstanceModal","dispatchKafkaAction","showMetrics","FederatedContext","useFederated","resources","en","translation","de","kafkai18n","use","initReactI18next","init","detection","order","caches","fallbackLng","debug","interpolation","escapeValue","KafkaActions","convertRetentionTime","milliseconds","convertedValue","Math","round","toString","convertRetentionSize","byte","convertedByteValue","abs"],"mappings":"oXAaaA,EAAuD,SAAC,G,IACnEC,EAAa,gBACbC,EAAY,eACS,OACrB,kBAAC,EAAAC,SAAQ,KAAKF,GACZ,kBAAC,EAAAG,QAAO,KAAKF,O,qTChBXG,GAAc,IAAAC,OAClB,WAAM,4FAEFC,GAAmB,IAAAD,OACvB,WAAM,wCAEFE,GAAsB,IAAAF,OAC1B,WACE,4FAKSG,EAAc,CACzBC,aAAc,eACdC,sBAAuB,wBACvBC,kBAAmB,qBAGfC,IAAgB,MACnBJ,EAAYC,cAAeL,EAC5B,EAACI,EAAYE,uBAAwBH,EACrC,EAACC,EAAYG,mBAAoBL,E,GAe7BO,GAAmB,IAAAC,eANa,CACpCC,UAAW,WAAM,UACjBC,UAAW,WAAM,UACjBC,MAAO,KAIIC,EAAsB,WACjC,WAAAC,YAAWN,IAEAO,EAAsB,SAAC,G,IAuB1BC,EAvB4BC,EAAQ,WACtC,GAAoB,IAAAC,YAAnBN,EAAK,KAAEO,EAAQ,KAChB,EAA4BP,GAAS,CAAEQ,UAAW,GAAIC,WAAY,IAAhED,EAAS,YAAEC,EAAU,aA4B7B,OACE,kBAAC,aAAc,CAACC,SAAU,kBAAC,IAAU,OACnC,kBAACd,EAAiBe,SAAQ,CAACC,MAAO,CAAEZ,MAAK,EAAEF,UA5B7B,SAACU,EAAmBC,GACpC,IAAMI,EAAWC,OAAOC,OAAO,GAAIf,GACnCO,EAAS,CACPM,SAAQ,EACRL,UAAS,EACTC,WAAU,KAuB4CV,UAnBxC,WAChB,IAAMc,EAAWC,OAAOC,OAAO,GAAIf,GACnCO,EAAS,CACPM,SAAQ,EACRL,UAAW,KACXC,WAAY,SAKRL,EAAiBT,EAAiBa,GACnCA,GAAcJ,EAGZ,kBAACA,EAAc,GAACY,GAAG,cAAiBP,IAFlC,MASJJ,M,6DCtEIY,E,MAAgB,sBAC3BC,I,qECYIC,EAA+B,CACnCC,iBAAkB,WAAM,UACxBC,sBAAuB,WAAM,UAC7BC,UAAW,EACXC,UAAW,GACXC,cAAe,GACfC,kBAAmB,GACnBC,UAAW,GACXC,QAAS,WAAM,UACfC,qBAAsB,WAAM,UAC5BC,6BAA8B,WAAM,UACpCC,oBAAqB,WAAM,UAC3BC,YAAa,cAGFC,E,MACX,iBAAoCb,GACzBc,EAAe,WAAsB,WAAA/B,YAAW8B,K,qGClCtD,IAAME,EAAY,CACvBC,GAAI,CACFC,Y,k3dAEFC,GAAI,CACFD,Y,mfCAEE,EAAY,qBAElBA,EAEGC,IAAI,EAAAC,kBACJD,IAAI,KAGJE,KAAK,CACJC,UAAW,CACTC,MAAO,CAAC,UAAW,aACnBC,OAAQ,IAEVC,YAAa,KACbC,OAAO,EAEPC,cAAe,CACbC,aAAa,GAEfd,UAAS,IAGb,W,6BC1BA,IAAYe,E,oCAAZ,SAAYA,GACV,0BACA,4BACA,8BACA,4BAJF,CAAYA,MAAY,KAOjB,IAAMC,EAAuB,SAACC,GACnC,IAAIC,EACJ,OAAsB,IAAlBD,EACK,YACEA,EAAe,IACH,IAAjBA,EAA2BA,iBACnBA,kBACHA,GAAgB,KAASA,EAAe,MACjDC,EAAiBD,EAAe,IAET,KADvBC,EAAiBC,KAAKC,MAAuB,IAAjBF,GAAwB,KACnBA,YACrBA,cACHD,GAAgB,MAASA,EAAe,QACjDC,EAAiBD,EAAe,KAET,KADvBC,EAAiBC,KAAKC,MAAuB,IAAjBF,GAAwB,KACnBA,UACrBA,YACHD,GAAgB,QACzBC,EAAiBD,EAAe,OAChCC,EAAiBC,KAAKC,MAAuB,IAAjBF,GAAwB,KAC7CA,SAEFD,EAAaI,YAGTC,EAAuB,SAACC,GACnC,IAAIC,EACJ,OAAc,IAAVD,EACK,YACEJ,KAAKM,IAAIF,GAAQ,IACb,IAATA,EAAmBA,UACXA,WACHJ,KAAKM,IAAIF,IAAS,KAAQJ,KAAKM,IAAIF,GAAQ,IAEzB,KAD3BC,EAAqBD,EAAO,KACSC,cACzBA,eACHL,KAAKM,IAAIF,IAAS,KAAWJ,KAAKM,IAAIF,GAAQ,IAE5B,KAD3BC,EAAqBD,EAAO,KACSC,cACzBA,eACHL,KAAKM,IAAIF,IAAS,KAAcJ,KAAKM,IAAIF,GAAQ,KAE/B,KAD3BC,EAAqBD,EAAO,KACSC,cACzBA,eACHL,KAAKM,IAAIF,IAAS,KAEA,KAD3BC,EAAqBD,EAAO,MACSC,cACzBA,eAEPD,EAAKF","file":"837.4ef669f3.bundle.js","sourcesContent":["import React from 'react';\nimport {\n  Bullseye,\n  BullseyeProps,\n  Spinner,\n  SpinnerProps,\n} from '@patternfly/react-core';\n\nexport type MASLoadingProps = {\n  bullseyeProps?: Omit<BullseyeProps, 'children'>;\n  spinnerProps?: SpinnerProps;\n};\n\nexport const MASLoading: React.FunctionComponent<MASLoadingProps> = ({\n  bullseyeProps,\n  spinnerProps,\n}: MASLoadingProps) => (\n  <Bullseye {...bullseyeProps}>\n    <Spinner {...spinnerProps} />\n  </Bullseye>\n);\n","import React, { useState, createContext, useContext, lazy } from 'react';\nimport { MASLoading } from '@app/components';\nconst DeleteTopic = lazy(\n  () => import('@app/modules/Topics/dialogs/DeleteTopic/DeleteTopic')\n);\nconst PartitionsChange = lazy(\n  () => import('@app/modules/Topics/dialogs/PartitionsChange/PartitionsChange')\n);\nconst DeleteConsumerGroup = lazy(\n  () =>\n    import(\n      '@app/modules/ConsumerGroups/dialogs/DeleteConsumerGroup/DeleteConsumerGroup'\n    )\n);\n\nexport const MODAL_TYPES = {\n  DELETE_TOPIC: 'DELETE_TOPIC',\n  DELETE_CONSUMER_GROUP: 'DELETE_CONSUMER_GROUP',\n  UPDATE_PARTITIONS: 'UPDATE_PARTITIONS',\n};\n\nconst MODAL_COMPONENTS: any = {\n  [MODAL_TYPES.DELETE_TOPIC]: DeleteTopic,\n  [MODAL_TYPES.DELETE_CONSUMER_GROUP]: DeleteConsumerGroup,\n  [MODAL_TYPES.UPDATE_PARTITIONS]: PartitionsChange,\n};\n\ntype RootModalContext = {\n  showModal: (modalType: string, modalProps?: any) => void;\n  hideModal: () => void;\n  store: any;\n};\n\nconst initalState: RootModalContext = {\n  showModal: () => '',\n  hideModal: () => '',\n  store: '',\n};\n\nconst RootModalContext = createContext(initalState);\nexport const useRootModalContext = (): RootModalContext =>\n  useContext(RootModalContext);\n\nexport const RootModal: React.FC = ({ children }) => {\n  const [store, setStore] = useState<any>();\n  const { modalType, modalProps } = store || { modalType: '', modalProps: '' };\n\n  const showModal = (modalType: string, modalProps: any) => {\n    const newState = Object.assign({}, store);\n    setStore({\n      newState,\n      modalType,\n      modalProps,\n    });\n  };\n\n  const hideModal = () => {\n    const newState = Object.assign({}, store);\n    setStore({\n      newState,\n      modalType: null,\n      modalProps: '',\n    });\n  };\n\n  const renderComponent = () => {\n    const ModalComponent = MODAL_COMPONENTS[modalType];\n    if (!modalType || !ModalComponent) {\n      return null;\n    }\n    return <ModalComponent id='root-modal' {...modalProps} />;\n  };\n\n  return (\n    <React.Suspense fallback={<MASLoading />}>\n      <RootModalContext.Provider value={{ store, showModal, hideModal }}>\n        {renderComponent()}\n        {children}\n      </RootModalContext.Provider>\n    </React.Suspense>\n  );\n};\n","import React from 'react';\n\nexport type IConfiguration = {\n  basePath: string;\n  getToken: () => Promise<string>;\n};\n\nexport const ConfigContext = React.createContext<IConfiguration | undefined>(\n  undefined\n);\n","import React, { useContext } from 'react';\n\nexport type FederatedProps = {\n  onConnectToRoute?: (routePath: string) => void;\n  getConnectToRoutePath?: (routePath: string, key?: string) => string;\n  activeTab?: number;\n  kafkaName?: string;\n  kafkaPageLink?: string;\n  kafkaInstanceLink?: string;\n  topicName?: string;\n  onError?: (errorCode: number, message?: string) => void;\n  handleInstanceDrawer?: (isOpen: boolean, activeTab?: string) => void;\n  setIsOpenDeleteInstanceModal?: (isOpenModal: boolean) => void;\n  dispatchKafkaAction?: (\n    action: string,\n    topicName?: string | undefined\n  ) => void;\n  showMetrics?: () => JSX.Element | undefined;\n};\n\nconst initialState: FederatedProps = {\n  onConnectToRoute: () => '',\n  getConnectToRoutePath: () => '',\n  activeTab: 0,\n  kafkaName: '',\n  kafkaPageLink: '',\n  kafkaInstanceLink: '',\n  topicName: '',\n  onError: () => '',\n  handleInstanceDrawer: () => '',\n  setIsOpenDeleteInstanceModal: () => '',\n  dispatchKafkaAction: () => '',\n  showMetrics: () => undefined,\n};\n\nexport const FederatedContext =\n  React.createContext<FederatedProps>(initialState);\nexport const useFederated = (): FederatedProps => useContext(FederatedContext);\n","import en from './en.json';\nimport de from './de.json';\n\nexport const resources = {\n  en: {\n    translation: en,\n  },\n  de: {\n    translation: de,\n  },\n};\n","import i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport { resources } from './locale';\n// don't want to use this?\n// have a look at the Quick start guide\n// for passing in lng and translations on init\n\nconst kafkai18n = i18n.createInstance();\n\nkafkai18n\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  .use(LanguageDetector)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    detection: {\n      order: ['htmlTag', 'navigator'],\n      caches: [],\n    },\n    fallbackLng: 'en',\n    debug: true,\n\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    resources,\n  });\n\nexport default kafkai18n;\n","export interface FederatedProps {\n  onError: (errorCode: number, message: string) => void;\n}\n\nexport enum KafkaActions {\n  ViewTopics = 'ViewTopics',\n  CreateTopic = 'CreateTopic',\n  DetailsTopic = 'DetailsTopic',\n  UpdateTopic = 'UpdateTopic',\n}\n\nexport const convertRetentionTime = (milliseconds: number): string => {\n  let convertedValue;\n  if (milliseconds === -1) {\n    return 'Unlimited';\n  } else if (milliseconds < 60000) {\n    if (milliseconds === 1) return milliseconds + ' ' + 'millisecond';\n    else return milliseconds + ' ' + 'milliseconds';\n  } else if (milliseconds >= 60000 && milliseconds < 3.6e6) {\n    convertedValue = milliseconds / 60000;\n    convertedValue = Math.round(convertedValue * 100) / 100;\n    if (convertedValue === 1) return convertedValue + ' ' + 'minute';\n    else return convertedValue + ' ' + 'minutes';\n  } else if (milliseconds >= 3.6e6 && milliseconds < 1.728e8) {\n    convertedValue = milliseconds / 3.6e6;\n    convertedValue = Math.round(convertedValue * 100) / 100;\n    if (convertedValue === 1) return convertedValue + ' ' + 'hour';\n    else return convertedValue + ' ' + 'hours';\n  } else if (milliseconds >= 1.728e8) {\n    convertedValue = milliseconds / 8.64e7;\n    convertedValue = Math.round(convertedValue * 100) / 100;\n    return convertedValue + ' ' + 'days';\n  }\n  return milliseconds.toString();\n};\n\nexport const convertRetentionSize = (byte: number): string => {\n  let convertedByteValue;\n  if (byte === -1) {\n    return 'Unlimited';\n  } else if (Math.abs(byte) < 1000) {\n    if (byte === 1) return byte + ' ' + 'byte';\n    else return byte + ' ' + 'bytes';\n  } else if (Math.abs(byte) >= 1000 && Math.abs(byte) < 1000000) {\n    convertedByteValue = byte / 1000;\n    if (convertedByteValue === 1) return convertedByteValue + ' ' + 'kilobyte';\n    else return convertedByteValue + ' ' + 'kilobytes';\n  } else if (Math.abs(byte) >= 1000000 && Math.abs(byte) < 1000000000) {\n    convertedByteValue = byte / 1000000;\n    if (convertedByteValue === 1) return convertedByteValue + ' ' + 'megabyte';\n    else return convertedByteValue + ' ' + 'megabytes';\n  } else if (Math.abs(byte) >= 1000000000 && Math.abs(byte) < 1000000000000) {\n    convertedByteValue = byte / 1000000000;\n    if (convertedByteValue === 1) return convertedByteValue + ' ' + 'gigabyte';\n    else return convertedByteValue + ' ' + 'gigabytes';\n  } else if (Math.abs(byte) >= 1000000000000) {\n    convertedByteValue = byte / 1000000000000;\n    if (convertedByteValue === 1) return convertedByteValue + ' ' + 'terabyte';\n    else return convertedByteValue + ' ' + 'terabytes';\n  }\n  return byte.toString();\n};\n"],"sourceRoot":""}