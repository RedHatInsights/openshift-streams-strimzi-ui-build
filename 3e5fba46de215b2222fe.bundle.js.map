{"version":3,"sources":["webpack://kafka-ui/./src/Contexts/Api/Context.tsx","webpack://kafka-ui/./src/OpenApi/base.ts","webpack://kafka-ui/./src/OpenApi/api.ts","webpack://kafka-ui/./src/OpenApi/configuration.ts"],"names":["ConfigContext","undefined","BASE_PATH","replace","field","msg","name","Error","DefaultApiAxiosParamCreator","configuration","createTopic","newTopicInput","options","RequiredError","localVarUrlObj","URL","baseOptions","localVarRequestOptions","method","localVarHeaderParameter","localVarQueryParameter","accessToken","key","queryParameters","URLSearchParams","search","set","query","toString","headersFromBaseOptions","headers","needsSerialization","nonString","isJsonMime","data","JSON","stringify","url","pathname","hash","deleteTopic","topicName","localVarPath","encodeURIComponent","String","getTopic","getTopicsList","limit","filter","offset","updateTopic","topicSettings","DefaultApiFp","localVarAxiosArgs","axios","basePath","axiosRequestArgs","request","this","then","param","apiKey","username","password","formDataCtor","mime","jsonMime","RegExp","test","toLowerCase"],"mappings":"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","file":"3e5fba46de215b2222fe.bundle.js","sourcesContent":["import React from 'react';\n\nexport type IConfiguration = {\n  basePath: string;\n  getToken: () => Promise<string>;\n};\n\nexport const ConfigContext = React.createContext<IConfiguration | undefined>(\n  undefined\n);\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Strimzi Kubernetes REST API\n * An API to provide k8s REST endpoints for query\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Configuration } from './configuration';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\n\nexport const BASE_PATH = 'https://api.openshift.com/api/managed-services-strimzi-ui/v1/api'.replace(\n  /\\/+$/,\n  ''\n);\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n  csv: ',',\n  ssv: ' ',\n  tsv: '\\t',\n  pipes: '|',\n};\n\n/**\n *\n * @export\n * @interface RequestArgs\n */\nexport interface RequestArgs {\n  url: string;\n  options: any;\n}\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPI {\n  protected configuration: Configuration | undefined;\n\n  constructor(\n    configuration?: Configuration,\n    protected basePath: string = BASE_PATH,\n    protected axios: AxiosInstance = globalAxios\n  ) {\n    if (configuration) {\n      this.configuration = configuration;\n      this.basePath = configuration.basePath || this.basePath;\n    }\n  }\n}\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n  name: 'RequiredError' = 'RequiredError';\n  constructor(public field: string, msg?: string) {\n    super(msg);\n  }\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Strimzi Kubernetes REST API\n * An API to provide k8s REST endpoints for query\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Configuration } from './configuration';\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport {\n  BASE_PATH,\n  COLLECTION_FORMATS,\n  RequestArgs,\n  BaseAPI,\n  RequiredError,\n} from './base';\n\n/**\n * Key value pair indicating possible configuration options for a topic.\n * @export\n * @interface ConfigEntry\n */\nexport interface ConfigEntry {\n  /**\n   * The key indicating what configuration entry you would like to set for the topic.\n   * @type {string}\n   * @memberof ConfigEntry\n   */\n  key?: string;\n  /**\n   * Value to indicate the setting on the topic configuration entry.\n   * @type {string}\n   * @memberof ConfigEntry\n   */\n  value?: string;\n}\n/**\n * Input object to create a new topic.\n * @export\n * @interface NewTopicInput\n */\nexport interface NewTopicInput {\n  /**\n   * The topic name, this value must be unique.\n   * @type {string}\n   * @memberof NewTopicInput\n   */\n  name: string;\n  /**\n   *\n   * @type {TopicSettings}\n   * @memberof NewTopicInput\n   */\n  settings?: TopicSettings;\n}\n/**\n * Kafka topic partition\n * @export\n * @interface Partition\n */\nexport interface Partition {\n  /**\n   * Uniquie id for the partition\n   * @type {number}\n   * @memberof Partition\n   */\n  id: number;\n  /**\n   * List of replicas for the partition\n   * @type {Array<object>}\n   * @memberof Partition\n   */\n  replicas?: Array<object>;\n  /**\n   * List isync-replicas for this partition.\n   * @type {Array<object>}\n   * @memberof Partition\n   */\n  isr?: Array<object>;\n  /**\n   * Kafka server / broker.\n   * @type {object}\n   * @memberof Partition\n   */\n  leader?: object;\n}\n/**\n * Kafka Topic (A feed where records are stored and published)\n * @export\n * @interface Topic\n */\nexport interface Topic {\n  /**\n   * The name of the topic.\n   * @type {string}\n   * @memberof Topic\n   */\n  name?: string;\n  /**\n   * Topic configuration entry.\n   * @type {Array<ConfigEntry>}\n   * @memberof Topic\n   */\n  config?: Array<ConfigEntry>;\n  /**\n   * Partitions for this topic.\n   * @type {Array<Partition>}\n   * @memberof Topic\n   */\n  partitions?: Array<Partition>;\n}\n/**\n * Kafka Topic (A feed where records are stored and published)\n * @export\n * @interface TopicSettings\n */\nexport interface TopicSettings {\n  /**\n   * Number of partitions for this topic.\n   * @type {number}\n   * @memberof TopicSettings\n   */\n  numPartitions?: number;\n  /**\n   * Number of replications for the topic.\n   * @type {number}\n   * @memberof TopicSettings\n   */\n  replicationFactor?: number;\n  /**\n   * Topic configuration entry.\n   * @type {Array<ConfigEntry>}\n   * @memberof TopicSettings\n   */\n  config?: Array<ConfigEntry>;\n}\n/**\n * A list of topics.\n * @export\n * @interface TopicsList\n */\nexport interface TopicsList {\n  /**\n   * List of topics\n   * @type {Array<Topic>}\n   * @memberof TopicsList\n   */\n  items?: Array<Topic>;\n  /**\n   * The page offset\n   * @type {number}\n   * @memberof TopicsList\n   */\n  offset: number;\n  /**\n   * number of entries per page\n   * @type {number}\n   * @memberof TopicsList\n   */\n  limit: number;\n  /**\n   * Total number of topics\n   * @type {number}\n   * @memberof TopicsList\n   */\n  count: number;\n}\n\n/**\n * DefaultApi - axios parameter creator\n * @export\n */\nexport const DefaultApiAxiosParamCreator = function (\n  configuration?: Configuration\n) {\n  return {\n    /**\n     * Creates a new topic in Kafka.\n     * @summary Creates a new topic\n     * @param {NewTopicInput} newTopicInput Topic to create.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    createTopic: async (\n      newTopicInput: NewTopicInput,\n      options: any = {}\n    ): Promise<RequestArgs> => {\n      // verify required parameter 'newTopicInput' is not null or undefined\n      if (newTopicInput === null || newTopicInput === undefined) {\n        throw new RequiredError(\n          'newTopicInput',\n          'Required parameter newTopicInput was null or undefined when calling createTopic.'\n        );\n      }\n      const localVarPath = `/topics`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, 'https://example.com');\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n\n      const localVarRequestOptions = {\n        method: 'POST',\n        ...baseOptions,\n        ...options,\n      };\n      const localVarHeaderParameter = {} as any;\n      const localVarQueryParameter = {} as any;\n\n      // authentication Bearer required\n      // http bearer authentication required\n      if (configuration && configuration.accessToken) {\n        const accessToken =\n          typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;\n      }\n\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n\n      const queryParameters = new URLSearchParams(localVarUrlObj.search);\n      for (const key in localVarQueryParameter) {\n        queryParameters.set(key, localVarQueryParameter[key]);\n      }\n      for (const key in options.query) {\n        queryParameters.set(key, options.query[key]);\n      }\n      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();\n      let headersFromBaseOptions =\n        baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = {\n        ...localVarHeaderParameter,\n        ...headersFromBaseOptions,\n        ...options.headers,\n      };\n      const nonString = typeof newTopicInput !== 'string';\n      const needsSerialization =\n        nonString && configuration && configuration.isJsonMime\n          ? configuration.isJsonMime(\n              localVarRequestOptions.headers['Content-Type']\n            )\n          : nonString;\n      localVarRequestOptions.data = needsSerialization\n        ? JSON.stringify(newTopicInput !== undefined ? newTopicInput : {})\n        : newTopicInput || '';\n\n      return {\n        url:\n          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,\n        options: localVarRequestOptions,\n      };\n    },\n    /**\n     * Deletes the topic with the specified name.\n     * @summary Deletes a  topic\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    deleteTopic: async (\n      topicName: string,\n      options: any = {}\n    ): Promise<RequestArgs> => {\n      // verify required parameter 'topicName' is not null or undefined\n      if (topicName === null || topicName === undefined) {\n        throw new RequiredError(\n          'topicName',\n          'Required parameter topicName was null or undefined when calling deleteTopic.'\n        );\n      }\n      const localVarPath = `/topics/{topicName}`.replace(\n        `{${'topicName'}}`,\n        encodeURIComponent(String(topicName))\n      );\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, 'https://example.com');\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n\n      const localVarRequestOptions = {\n        method: 'DELETE',\n        ...baseOptions,\n        ...options,\n      };\n      const localVarHeaderParameter = {} as any;\n      const localVarQueryParameter = {} as any;\n\n      // authentication Bearer required\n      // http bearer authentication required\n      if (configuration && configuration.accessToken) {\n        const accessToken =\n          typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;\n      }\n\n      const queryParameters = new URLSearchParams(localVarUrlObj.search);\n      for (const key in localVarQueryParameter) {\n        queryParameters.set(key, localVarQueryParameter[key]);\n      }\n      for (const key in options.query) {\n        queryParameters.set(key, options.query[key]);\n      }\n      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();\n      let headersFromBaseOptions =\n        baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = {\n        ...localVarHeaderParameter,\n        ...headersFromBaseOptions,\n        ...options.headers,\n      };\n\n      return {\n        url:\n          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,\n        options: localVarRequestOptions,\n      };\n    },\n    /**\n     * Topic\n     * @summary Retrieves the topic with the specified name.\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    getTopic: async (\n      topicName: string,\n      options: any = {}\n    ): Promise<RequestArgs> => {\n      // verify required parameter 'topicName' is not null or undefined\n      if (topicName === null || topicName === undefined) {\n        throw new RequiredError(\n          'topicName',\n          'Required parameter topicName was null or undefined when calling getTopic.'\n        );\n      }\n      const localVarPath = `/topics/{topicName}`.replace(\n        `{${'topicName'}}`,\n        encodeURIComponent(String(topicName))\n      );\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, 'https://example.com');\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n\n      const localVarRequestOptions = {\n        method: 'GET',\n        ...baseOptions,\n        ...options,\n      };\n      const localVarHeaderParameter = {} as any;\n      const localVarQueryParameter = {} as any;\n\n      // authentication Bearer required\n      // http bearer authentication required\n      if (configuration && configuration.accessToken) {\n        const accessToken =\n          typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;\n      }\n\n      const queryParameters = new URLSearchParams(localVarUrlObj.search);\n      for (const key in localVarQueryParameter) {\n        queryParameters.set(key, localVarQueryParameter[key]);\n      }\n      for (const key in options.query) {\n        queryParameters.set(key, options.query[key]);\n      }\n      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();\n      let headersFromBaseOptions =\n        baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = {\n        ...localVarHeaderParameter,\n        ...headersFromBaseOptions,\n        ...options.headers,\n      };\n\n      return {\n        url:\n          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,\n        options: localVarRequestOptions,\n      };\n    },\n    /**\n     * Returns a list of all of the available topics, or the list of topics that meet the users URL Query Parameters.\n     * @summary List of topics\n     * @param {number} [limit] Maximum number of topics to return\n     * @param {string} [filter] Filter to apply when returning the list of topics\n     * @param {number} [offset] The page offset when returning  the limit of requested topics.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    getTopicsList: async (\n      limit?: number,\n      filter?: string,\n      offset?: number,\n      options: any = {}\n    ): Promise<RequestArgs> => {\n      const localVarPath = `/topics`;\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, 'https://example.com');\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n\n      const localVarRequestOptions = {\n        method: 'GET',\n        ...baseOptions,\n        ...options,\n      };\n      const localVarHeaderParameter = {} as any;\n      const localVarQueryParameter = {} as any;\n\n      // authentication Bearer required\n      // http bearer authentication required\n      if (configuration && configuration.accessToken) {\n        const accessToken =\n          typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;\n      }\n\n      if (limit !== undefined) {\n        localVarQueryParameter['limit'] = limit;\n      }\n\n      if (filter !== undefined) {\n        localVarQueryParameter['filter'] = filter;\n      }\n\n      if (offset !== undefined) {\n        localVarQueryParameter['offset'] = offset;\n      }\n\n      const queryParameters = new URLSearchParams(localVarUrlObj.search);\n      for (const key in localVarQueryParameter) {\n        queryParameters.set(key, localVarQueryParameter[key]);\n      }\n      for (const key in options.query) {\n        queryParameters.set(key, options.query[key]);\n      }\n      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();\n      let headersFromBaseOptions =\n        baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = {\n        ...localVarHeaderParameter,\n        ...headersFromBaseOptions,\n        ...options.headers,\n      };\n\n      return {\n        url:\n          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,\n        options: localVarRequestOptions,\n      };\n    },\n    /**\n     * updates the topic with the new data.\n     * @summary Updates the topic with the specified name.\n     * @param {string} topicName The topic name which is its unique id.\n     * @param {TopicSettings} topicSettings\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    updateTopic: async (\n      topicName: string,\n      topicSettings: TopicSettings,\n      options: any = {}\n    ): Promise<RequestArgs> => {\n      // verify required parameter 'topicName' is not null or undefined\n      if (topicName === null || topicName === undefined) {\n        throw new RequiredError(\n          'topicName',\n          'Required parameter topicName was null or undefined when calling updateTopic.'\n        );\n      }\n      // verify required parameter 'topicSettings' is not null or undefined\n      if (topicSettings === null || topicSettings === undefined) {\n        throw new RequiredError(\n          'topicSettings',\n          'Required parameter topicSettings was null or undefined when calling updateTopic.'\n        );\n      }\n      const localVarPath = `/topics/{topicName}`.replace(\n        `{${'topicName'}}`,\n        encodeURIComponent(String(topicName))\n      );\n      // use dummy base URL string because the URL constructor only accepts absolute URLs.\n      const localVarUrlObj = new URL(localVarPath, 'https://example.com');\n      let baseOptions;\n      if (configuration) {\n        baseOptions = configuration.baseOptions;\n      }\n\n      const localVarRequestOptions = {\n        method: 'PATCH',\n        ...baseOptions,\n        ...options,\n      };\n      const localVarHeaderParameter = {} as any;\n      const localVarQueryParameter = {} as any;\n\n      // authentication Bearer required\n      // http bearer authentication required\n      if (configuration && configuration.accessToken) {\n        const accessToken =\n          typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;\n      }\n\n      localVarHeaderParameter['Content-Type'] = 'application/json';\n\n      const queryParameters = new URLSearchParams(localVarUrlObj.search);\n      for (const key in localVarQueryParameter) {\n        queryParameters.set(key, localVarQueryParameter[key]);\n      }\n      for (const key in options.query) {\n        queryParameters.set(key, options.query[key]);\n      }\n      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();\n      let headersFromBaseOptions =\n        baseOptions && baseOptions.headers ? baseOptions.headers : {};\n      localVarRequestOptions.headers = {\n        ...localVarHeaderParameter,\n        ...headersFromBaseOptions,\n        ...options.headers,\n      };\n      const nonString = typeof topicSettings !== 'string';\n      const needsSerialization =\n        nonString && configuration && configuration.isJsonMime\n          ? configuration.isJsonMime(\n              localVarRequestOptions.headers['Content-Type']\n            )\n          : nonString;\n      localVarRequestOptions.data = needsSerialization\n        ? JSON.stringify(topicSettings !== undefined ? topicSettings : {})\n        : topicSettings || '';\n\n      return {\n        url:\n          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,\n        options: localVarRequestOptions,\n      };\n    },\n  };\n};\n\n/**\n * DefaultApi - functional programming interface\n * @export\n */\nexport const DefaultApiFp = function (configuration?: Configuration) {\n  return {\n    /**\n     * Creates a new topic in Kafka.\n     * @summary Creates a new topic\n     * @param {NewTopicInput} newTopicInput Topic to create.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    async createTopic(\n      newTopicInput: NewTopicInput,\n      options?: any\n    ): Promise<\n      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>\n    > {\n      const localVarAxiosArgs = await DefaultApiAxiosParamCreator(\n        configuration\n      ).createTopic(newTopicInput, options);\n      return (\n        axios: AxiosInstance = globalAxios,\n        basePath: string = BASE_PATH\n      ) => {\n        const axiosRequestArgs = {\n          ...localVarAxiosArgs.options,\n          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,\n        };\n        return axios.request(axiosRequestArgs);\n      };\n    },\n    /**\n     * Deletes the topic with the specified name.\n     * @summary Deletes a  topic\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    async deleteTopic(\n      topicName: string,\n      options?: any\n    ): Promise<\n      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>\n    > {\n      const localVarAxiosArgs = await DefaultApiAxiosParamCreator(\n        configuration\n      ).deleteTopic(topicName, options);\n      return (\n        axios: AxiosInstance = globalAxios,\n        basePath: string = BASE_PATH\n      ) => {\n        const axiosRequestArgs = {\n          ...localVarAxiosArgs.options,\n          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,\n        };\n        return axios.request(axiosRequestArgs);\n      };\n    },\n    /**\n     * Topic\n     * @summary Retrieves the topic with the specified name.\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    async getTopic(\n      topicName: string,\n      options?: any\n    ): Promise<\n      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>\n    > {\n      const localVarAxiosArgs = await DefaultApiAxiosParamCreator(\n        configuration\n      ).getTopic(topicName, options);\n      return (\n        axios: AxiosInstance = globalAxios,\n        basePath: string = BASE_PATH\n      ) => {\n        const axiosRequestArgs = {\n          ...localVarAxiosArgs.options,\n          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,\n        };\n        return axios.request(axiosRequestArgs);\n      };\n    },\n    /**\n     * Returns a list of all of the available topics, or the list of topics that meet the users URL Query Parameters.\n     * @summary List of topics\n     * @param {number} [limit] Maximum number of topics to return\n     * @param {string} [filter] Filter to apply when returning the list of topics\n     * @param {number} [offset] The page offset when returning  the limit of requested topics.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    async getTopicsList(\n      limit?: number,\n      filter?: string,\n      offset?: number,\n      options?: any\n    ): Promise<\n      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicsList>\n    > {\n      const localVarAxiosArgs = await DefaultApiAxiosParamCreator(\n        configuration\n      ).getTopicsList(limit, filter, offset, options);\n      return (\n        axios: AxiosInstance = globalAxios,\n        basePath: string = BASE_PATH\n      ) => {\n        const axiosRequestArgs = {\n          ...localVarAxiosArgs.options,\n          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,\n        };\n        return axios.request(axiosRequestArgs);\n      };\n    },\n    /**\n     * updates the topic with the new data.\n     * @summary Updates the topic with the specified name.\n     * @param {string} topicName The topic name which is its unique id.\n     * @param {TopicSettings} topicSettings\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    async updateTopic(\n      topicName: string,\n      topicSettings: TopicSettings,\n      options?: any\n    ): Promise<\n      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic>\n    > {\n      const localVarAxiosArgs = await DefaultApiAxiosParamCreator(\n        configuration\n      ).updateTopic(topicName, topicSettings, options);\n      return (\n        axios: AxiosInstance = globalAxios,\n        basePath: string = BASE_PATH\n      ) => {\n        const axiosRequestArgs = {\n          ...localVarAxiosArgs.options,\n          url: (configuration?.basePath || basePath) + localVarAxiosArgs.url,\n        };\n        return axios.request(axiosRequestArgs);\n      };\n    },\n  };\n};\n\n/**\n * DefaultApi - factory interface\n * @export\n */\nexport const DefaultApiFactory = function (\n  configuration?: Configuration,\n  basePath?: string,\n  axios?: AxiosInstance\n) {\n  return {\n    /**\n     * Creates a new topic in Kafka.\n     * @summary Creates a new topic\n     * @param {NewTopicInput} newTopicInput Topic to create.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    createTopic(\n      newTopicInput: NewTopicInput,\n      options?: any\n    ): AxiosPromise<Topic> {\n      return DefaultApiFp(configuration)\n        .createTopic(newTopicInput, options)\n        .then((request) => request(axios, basePath));\n    },\n    /**\n     * Deletes the topic with the specified name.\n     * @summary Deletes a  topic\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    deleteTopic(topicName: string, options?: any): AxiosPromise<void> {\n      return DefaultApiFp(configuration)\n        .deleteTopic(topicName, options)\n        .then((request) => request(axios, basePath));\n    },\n    /**\n     * Topic\n     * @summary Retrieves the topic with the specified name.\n     * @param {string} topicName The topic name to retrieve.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    getTopic(topicName: string, options?: any): AxiosPromise<Topic> {\n      return DefaultApiFp(configuration)\n        .getTopic(topicName, options)\n        .then((request) => request(axios, basePath));\n    },\n    /**\n     * Returns a list of all of the available topics, or the list of topics that meet the users URL Query Parameters.\n     * @summary List of topics\n     * @param {number} [limit] Maximum number of topics to return\n     * @param {string} [filter] Filter to apply when returning the list of topics\n     * @param {number} [offset] The page offset when returning  the limit of requested topics.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    getTopicsList(\n      limit?: number,\n      filter?: string,\n      offset?: number,\n      options?: any\n    ): AxiosPromise<TopicsList> {\n      return DefaultApiFp(configuration)\n        .getTopicsList(limit, filter, offset, options)\n        .then((request) => request(axios, basePath));\n    },\n    /**\n     * updates the topic with the new data.\n     * @summary Updates the topic with the specified name.\n     * @param {string} topicName The topic name which is its unique id.\n     * @param {TopicSettings} topicSettings\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     */\n    updateTopic(\n      topicName: string,\n      topicSettings: TopicSettings,\n      options?: any\n    ): AxiosPromise<Topic> {\n      return DefaultApiFp(configuration)\n        .updateTopic(topicName, topicSettings, options)\n        .then((request) => request(axios, basePath));\n    },\n  };\n};\n\n/**\n * DefaultApi - interface\n * @export\n * @interface DefaultApi\n */\nexport interface DefaultApiInterface {\n  /**\n   * Creates a new topic in Kafka.\n   * @summary Creates a new topic\n   * @param {NewTopicInput} newTopicInput Topic to create.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApiInterface\n   */\n  createTopic(newTopicInput: NewTopicInput, options?: any): AxiosPromise<Topic>;\n\n  /**\n   * Deletes the topic with the specified name.\n   * @summary Deletes a  topic\n   * @param {string} topicName The topic name to retrieve.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApiInterface\n   */\n  deleteTopic(topicName: string, options?: any): AxiosPromise<void>;\n\n  /**\n   * Topic\n   * @summary Retrieves the topic with the specified name.\n   * @param {string} topicName The topic name to retrieve.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApiInterface\n   */\n  getTopic(topicName: string, options?: any): AxiosPromise<Topic>;\n\n  /**\n   * Returns a list of all of the available topics, or the list of topics that meet the users URL Query Parameters.\n   * @summary List of topics\n   * @param {number} [limit] Maximum number of topics to return\n   * @param {string} [filter] Filter to apply when returning the list of topics\n   * @param {number} [offset] The page offset when returning  the limit of requested topics.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApiInterface\n   */\n  getTopicsList(\n    limit?: number,\n    filter?: string,\n    offset?: number,\n    options?: any\n  ): AxiosPromise<TopicsList>;\n\n  /**\n   * updates the topic with the new data.\n   * @summary Updates the topic with the specified name.\n   * @param {string} topicName The topic name which is its unique id.\n   * @param {TopicSettings} topicSettings\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApiInterface\n   */\n  updateTopic(\n    topicName: string,\n    topicSettings: TopicSettings,\n    options?: any\n  ): AxiosPromise<Topic>;\n}\n\n/**\n * DefaultApi - object-oriented interface\n * @export\n * @class DefaultApi\n * @extends {BaseAPI}\n */\nexport class DefaultApi extends BaseAPI implements DefaultApiInterface {\n  /**\n   * Creates a new topic in Kafka.\n   * @summary Creates a new topic\n   * @param {NewTopicInput} newTopicInput Topic to create.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApi\n   */\n  public createTopic(newTopicInput: NewTopicInput, options?: any) {\n    return DefaultApiFp(this.configuration)\n      .createTopic(newTopicInput, options)\n      .then((request) => request(this.axios, this.basePath));\n  }\n\n  /**\n   * Deletes the topic with the specified name.\n   * @summary Deletes a  topic\n   * @param {string} topicName The topic name to retrieve.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApi\n   */\n  public deleteTopic(topicName: string, options?: any) {\n    return DefaultApiFp(this.configuration)\n      .deleteTopic(topicName, options)\n      .then((request) => request(this.axios, this.basePath));\n  }\n\n  /**\n   * Topic\n   * @summary Retrieves the topic with the specified name.\n   * @param {string} topicName The topic name to retrieve.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApi\n   */\n  public getTopic(topicName: string, options?: any) {\n    return DefaultApiFp(this.configuration)\n      .getTopic(topicName, options)\n      .then((request) => request(this.axios, this.basePath));\n  }\n\n  /**\n   * Returns a list of all of the available topics, or the list of topics that meet the users URL Query Parameters.\n   * @summary List of topics\n   * @param {number} [limit] Maximum number of topics to return\n   * @param {string} [filter] Filter to apply when returning the list of topics\n   * @param {number} [offset] The page offset when returning  the limit of requested topics.\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApi\n   */\n  public getTopicsList(\n    limit?: number,\n    filter?: string,\n    offset?: number,\n    options?: any\n  ) {\n    return DefaultApiFp(this.configuration)\n      .getTopicsList(limit, filter, offset, options)\n      .then((request) => request(this.axios, this.basePath));\n  }\n\n  /**\n   * updates the topic with the new data.\n   * @summary Updates the topic with the specified name.\n   * @param {string} topicName The topic name which is its unique id.\n   * @param {TopicSettings} topicSettings\n   * @param {*} [options] Override http request option.\n   * @throws {RequiredError}\n   * @memberof DefaultApi\n   */\n  public updateTopic(\n    topicName: string,\n    topicSettings: TopicSettings,\n    options?: any\n  ) {\n    return DefaultApiFp(this.configuration)\n      .updateTopic(topicName, topicSettings, options)\n      .then((request) => request(this.axios, this.basePath));\n  }\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Strimzi Kubernetes REST API\n * An API to provide k8s REST endpoints for query\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nexport interface ConfigurationParameters {\n  apiKey?:\n    | string\n    | Promise<string>\n    | ((name: string) => string)\n    | ((name: string) => Promise<string>);\n  username?: string;\n  password?: string;\n  accessToken?:\n    | string\n    | Promise<string>\n    | ((name?: string, scopes?: string[]) => string)\n    | ((name?: string, scopes?: string[]) => Promise<string>);\n  basePath?: string;\n  baseOptions?: any;\n  formDataCtor?: new () => any;\n}\n\nexport class Configuration {\n  /**\n   * parameter for apiKey security\n   * @param name security name\n   * @memberof Configuration\n   */\n  apiKey?:\n    | string\n    | Promise<string>\n    | ((name: string) => string)\n    | ((name: string) => Promise<string>);\n  /**\n   * parameter for basic security\n   *\n   * @type {string}\n   * @memberof Configuration\n   */\n  username?: string;\n  /**\n   * parameter for basic security\n   *\n   * @type {string}\n   * @memberof Configuration\n   */\n  password?: string;\n  /**\n   * parameter for oauth2 security\n   * @param name security name\n   * @param scopes oauth2 scope\n   * @memberof Configuration\n   */\n  accessToken?:\n    | string\n    | Promise<string>\n    | ((name?: string, scopes?: string[]) => string)\n    | ((name?: string, scopes?: string[]) => Promise<string>);\n  /**\n   * override base path\n   *\n   * @type {string}\n   * @memberof Configuration\n   */\n  basePath?: string;\n  /**\n   * base options for axios calls\n   *\n   * @type {any}\n   * @memberof Configuration\n   */\n  baseOptions?: any;\n  /**\n   * The FormData constructor that will be used to create multipart form data\n   * requests. You can inject this here so that execution environments that\n   * do not support the FormData class can still run the generated client.\n   *\n   * @type {new () => FormData}\n   */\n  formDataCtor?: new () => any;\n\n  constructor(param: ConfigurationParameters = {}) {\n    this.apiKey = param.apiKey;\n    this.username = param.username;\n    this.password = param.password;\n    this.accessToken = param.accessToken;\n    this.basePath = param.basePath;\n    this.baseOptions = param.baseOptions;\n    this.formDataCtor = param.formDataCtor;\n  }\n\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  public isJsonMime(mime: string): boolean {\n    const jsonMime: RegExp = new RegExp(\n      '^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$',\n      'i'\n    );\n    return (\n      mime !== null &&\n      (jsonMime.test(mime) ||\n        mime.toLowerCase() === 'application/json-patch+json')\n    );\n  }\n}\n"],"sourceRoot":""}